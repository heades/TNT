\usepackage{amssymb,amsmath,amsthm}
\usepackage{stmaryrd}
\usepackage{todonotes}
\usepackage{mathpartir}
\usepackage{enumerate}
\usepackage{hyperref}

\usepackage[barr]{xy}
\let\mto\to
\let\to\rightarrow

\usepackage{color}
\usepackage{supertabular}
\include{type-theory_inc}

% Ott includes.
\input{TNT-ott}

\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\uar}[0]{\mathop{\uparrow}}
\newcommand{\dar}[0]{\mathop{\downarrow}}
\newcommand{\st}[1]{\mathsf{st}_{#1}}
\newcommand{\case}[0]{\mathsf{case}}
\newcommand{\cur}[1]{\mathsf{cur}(#1)}
\newcommand{\app}[0]{\mathsf{app}}
\newcommand{\id}[0]{\mathsf{id}}
\newcommand{\ifrName}[1]{#1}
\let\t\relax
\newcommand{\t}[0]{\mathsf{t}}

\title{Adjoint Programming: Termination as an Effect}

\author{Harley Eades III\\
  Augusta University}

\begin{document}

\maketitle

\begin{abstract}
  ... 
\end{abstract}

\section{Introduction}
\label{sec:introduction}

It is a well-known fact about adjunctions that they induce a
monoad/comonad pair on some category.  Recently, adjunctions have been
proposed as an elegant model for resources and effects \cite{??}.
Even more recently, they have been proposed as a model of constructive
modal logic.  However, is it worthwhile to adopt adjunctions directly
into a programming language?  If they are adopted, then how do we
program with them?  In this paper we construct a typed
$\lambda$-calculus extended with an adjoint pair of functors with a
focus on programming.  Instead of working in completely generality we
instead focus on a single concrete, but interesting, example.

The Trellys Project was a large scale project to develop a general
purpose dependently type functional programming language \cite{??}.
The most important language design decision was to have the language
fragmented into two parts: a programmatic fragment and a logical
fragment.  The former is used to write general purpose programs, and
the latter is used to verify the correctness of the programs written
in the programmatic fragment.  This implies that there must be a means
for the logical fragment to take programs of the programmatic fragment
-- which we will call simply programs -- in as input to be able to
write predicates and proofs about those programs, but this must be
done so as to not compromise consistency of the logical fragment.  On
the other side of the coin the programmatic fragment should have the
ability to construct programs using the logical fragment.  This
property is called \textbf{freedom of speech}, because both fragments
have the ability to talk about each other without sacrificing their
integrity.

The running example of this paper is to approach this problem from a
categorical perspective. Suppose we have a cartesian closed category,
$\cat{L}$, and a cartesian closed category with fixpoints, $\cat{P}$.
It is well-known that $\cat{L}$ is a model of the simply-typed
$\lambda$-calculus \cite{?}, and $\cat{P}$ is a model of the
simply-typed $\lambda$-calculus with the $[[Y]]$ combinator \cite{?}.
The category $\cat{L}$ will model our logical fragment, and $\cat{P}$
our programmatic fragment.

Now suppose we have a symmetric monoidal adjunction $\cat{P} : T
\dashv D : \cat{L}$. We can think of this adjunction as a translation
between the two fragments.  It is a well-known fact about adjunctions
that the functor $\dar = DT : \cat{P} \to \cat{P}$ is a comonad, and
the functor $\uar = TD : \cat{L} \to \cat{L}$ is a monad.  The former
treats termination as a comonadic effect allowing the programmatic
fragment to restrict itself to terminating programs, and the latter
treats non-termination as a monadic effect allowing proofs to take in
as input potentially diverging programs.  Thus, we can see freedom of
speech as an adjoint situation.  It can also be shown that we have a
strong monad:
\[
\bfig
\morphism<1000,0>[A \times \uar B`\uar(A \times B);\st{A,B}]
\efig
\]
The previous strength can be defined using the fact that we have a
symmetric monoidal adjunction.

It does make a lot of since treating termination as a comonad.  Every
comonad is equipped with an operation $\varepsilon_X : \dar X \to X$.
We can view this comonad as transportation of terminating programs to
non-terminating programs.  That is, any terminating program is a
perfectly good diverging program.  This is one property the Trellys
project had difficulties accommodating.

One application where this is useful is in programming languages such
as Haskell where programmers by default program in potentially
diverging setting.  However, to gain assurances it is often preferred
to be able to pick and choose which programs one would want to be
terminating, and have it enforced by the type checker.  A termination
comonad would allow the programmer to develop their program under the
comonad to insure termination.

We will construct typed $\lambda$-calculi corresponding to both
$\cat{L}$ and $\cat{P}$ respectively.  Then we will bring these two
calculi together through a syntactic adjunction.  Then we will
consider various programmatic questions.  For example, every program
of type $\dar X$ should terminate, but proofs of type $\uar A$ should
be allowed to diverge.  In addition to these syntactic questions we
discuss novel contributions of these adjoint categorical models.

The first model of this kind is due to Benton \cite{??} who described
a similar situation for linear logic where $\cat{P}$ is a model of
linear logic, and $\cat{L}$ is a model of propositional logic, and
hence, the comonand $! : \cat{P} \to \cat{P}$ treats non-linearity as
a comonadic effect, but from the perspective of $\cat{L}$ linearity is
a monadic effect.  

\section{The Fragments and Their Semantics}
\label{sec:the_fragments_and_their_semantics}

We first must define the two fragments and give their semantics.  The
logic fragment will be kept simple and amounts to the simply-typed
$\lambda$-calculus, but the programmatic fragment will be slightly
more interesting.  Since we are interested in programming it will
contain the natural numbers, with a natural number eliminator in the
form of a case analysis, and the Y-combinator.  Each of the theories
will be presented using the style of Crole \cite{??}.

\subsection{The Logical Fragment}
\label{subsec:the_logical_fragment}

The logical fragment is defined in Figure~\ref{fig:log-type-rel} and
Figure~\ref{fig:log-eq}.
\begin{figure}
  \begin{mathpar}
    \scriptsize
    \TNTdruleLXXAx{} \and
    \TNTdruleLXXTrue{} \and
    \TNTdruleLXXProd{} \and
    \TNTdruleLXXProjOne{} \and
    \TNTdruleLXXProjTwo{} \and
    \TNTdruleLXXFun{} \and
    \TNTdruleLXXApp{}
  \end{mathpar}
  \caption{The Logical Fragment: Typing Relation}
  \label{fig:log-type-rel}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \scriptsize
    \TNTdruleLEqXXAx{} \and
    \TNTdruleLEqXXUnit{} \and
    \TNTdruleLEqXXProjOne{} \and
    \TNTdruleLEqXXProjTwo{} \and
    \TNTdruleLEqXXEtaP{} \and
    \TNTdruleLEqXXProjOneC{} \and
    \TNTdruleLEqXXProjTwoC{} \and
    \TNTdruleLEqXXPairC{} \and
    \TNTdruleLEqXXBeta{} \and
    \TNTdruleLEqXXEta{} \and
    \TNTdruleLEqXXFunC{} \and
    \TNTdruleLEqXXSubst{} \and
    \TNTdruleLEqXXWeak{} \and
    \TNTdruleLEqXXEx{} \and
    \TNTdruleLEqXXRefl{} \and
    \TNTdruleLEqXXSym{} \and
    \TNTdruleLEqXXTrans{}
  \end{mathpar}
  \caption{The Logical Fragment: Equality}
  \label{fig:log-eq}
\end{figure}
The following is a well-known fact \cite{Crole}.
\begin{lemma}
  \label{lemma:CCC-models-L}
  The logical fragment has a sound and complete interpretation into
  cartesian closed categories.
\end{lemma}
% subsection the_logical_fragment (end)

\subsection{The Programmatic Fragment}
\label{subsec:the_programmatic_fragment}
The programmatic fragment is a bit more interesting, and corresponds
to the simply-typed $\lambda$-calculus with natural numbers and the
Y-combinator.  The typing relation is defined in Figure~\ref{fig:prog-typing-rel}, and the terms-in-context inference rules are defined in Figure~\ref{fig:prog-eq}.
\begin{figure}
  \begin{mathpar}
    \scriptsize
    \TNTdrulePXXAx{} \and
    \TNTdrulePXXUnit{} \and
    \TNTdrulePXXZero{} \and
    \TNTdrulePXXSuc{} \and
    \TNTdrulePXXFix{} \and
    \TNTdrulePXXProd{} \and
    \TNTdrulePXXProjOne{} \and
    \TNTdrulePXXProjTwo{} \and
    \TNTdrulePXXFun{} \and
    \TNTdrulePXXApp{} \and
    \TNTdrulePXXCase{}
  \end{mathpar}
  \caption{Programmatic Fragment: Typing Relation}
  \label{fig:prog-typing-rel}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \scriptsize
    \TNTdrulePEqXXAx{} \and
    \TNTdrulePEqXXUnit{} \and
    \TNTdrulePEqXXProjOne{} \and
    \TNTdrulePEqXXProjTwo{} \and
    \TNTdrulePEqXXEtaP{} \and
    \TNTdrulePEqXXProjOneC{} \and
    \TNTdrulePEqXXProjTwoC{} \and
    \TNTdrulePEqXXPairC{} \and
    \TNTdrulePEqXXBeta{} \and
    \TNTdrulePEqXXEta{} \and
    \TNTdrulePEqXXFunC{} \and
    \TNTdrulePEqXXFix{} \and
    \TNTdrulePEqXXFixC{} \and
    \TNTdrulePEqXXSuc{} \and
    \TNTdrulePEqXXCaseB{} \and
    \TNTdrulePEqXXCaseS{} \and
    \TNTdrulePEqXXCaseC{} \and
    \TNTdrulePEqXXSubst{} \and
    \TNTdrulePEqXXWeak{} \and
    \TNTdrulePEqXXEx{} \and
    \TNTdrulePEqXXRefl{} \and
    \TNTdrulePEqXXSym{} \and
    \TNTdrulePEqXXTrans{} 
  \end{mathpar}
  \caption{Programmatic Fragment: Equality}
  \label{fig:prog-eq}
\end{figure}
The natural number eliminator, $\mathsf{case}$, can be mixed with the
Y-combinator to write generally recursive programs on the natural
numbers.  For example, the following defines natural number addition:
\[
  [[fix (\r.\n1.\n2.case n2 {
        0 -> n1,
        suc x -> suc (r n1 x)
      })]]
\]

The question now becomes how do we model $[[fix]]$ and $\mathsf{case}$
categorically?  To model $[[fix]]$ we endow a cartesian closed
category with fixpoints \cite{?}.

\begin{definition}
  \label{def:fixpoints-in-CCC}
  Suppose $\cat{C}$ is a cartesian closed category.  Then we say
  $\cat{C}$ \textbf{has fixpoints} if for any object $X$ of $\cat{C}$,
  there is a morphism $[[fix]]_X : (X \to X) \mto X$ such that the
  following diagram commutes:
  \[
  \bfig
  \qtriangle|amm|<1200,500>[
    X \to X`
    (X \to X) \times X`
    X;
    \langle \id_{X \to X}, [[fix]]_X \rangle`
    [[fix]]_X`
    \mathsf{app}_{X,X}]
  \efig
  \]
\end{definition}
\noindent
The commuting diagram in the above definition models the reduction
rule for $[[fix]]$, and so it is pretty easy to see that this
definition will allow us to model $[[fix]]$ categorically.

Perhaps more interestingly we use a novel approach to modeling
natural numbers with their eliminator.
\begin{definition}
  \label{def:SNNO}
  Suppose $\cat{C}$ is a cartesian closed category.  A
  \textbf{Scott natural number object (SNNO)} is an object $[[Nat]]$ of $\cat{C}$ and
  morphisms $\mathsf{z} : 1 \mto [[Nat]]$ and $[[suc]] : [[Nat]]  \mto [[Nat]]$ of $\cat{C}$,
  such that, for any morphisms $f : [[Y]] \mto X$ and $g : [[Y x Nat]] \mto X$ of $\cat{C}$ there is a unique morphism
  $\case_X : [[Y x Nat]] \mto X$ making the following diagrams commute:
       \[
       \begin{array}{lll}
         \bfig
         \qtriangle|amm|<1000,500>[
           [[Y x Nat]]`
           [[Y x Nat]]`
           X;
           \id_Y \times \mathsf{z}`
           \pi_1;f`
           \case_X]

         \ptriangle(1000,0)|amm|/<-`->`->/<1000,500>[
           [[Y x Nat]]`
           [[Y x Nat]]`
           X;
           \id_Y \times [[suc]]`
           \case_X`
           g ]
         \efig                               
       \end{array}
       \]
       Informally, the two diagrams essentially assert that we can
       define $u$ as follows:
       \begin{center}
         \begin{math}
           \begin{array}{rll}
             u\,y\,0 & = & f\,y\\
             u\,y\,[[(suc x)]] & = &  g\,y\,x
           \end{array}
         \end{math}
       \end{center}
\end{definition}

\noindent This formalization of natural numbers is inspired by the
definition of Scott Numerals \cite{??} where the notion of a case
distinction is built into the encoding. We can think of $[[Y]]$ in the
source object of $\case$ as the type additional inputs that will be
passed to both $f$ and $g$, but we can think of $[[Nat]]$ in the
source object of $\case$ as the type of the scrutiny.  Thus, since in
the base case there is no predecessor, $f$, will not require the
scrutiny, and so it is ignored.  

One major difference between SNNOs and the more traditional natural
number objects is that in the definition of the latter $g$ is defined
by well-founded recursion.  However, SNNOs do not allow this, but in
the presence of fixpoints we are able to regain this feature without
having to bake it into the definition of natural number objects.
However, to allow this we have found that when combining fixpoints and
case analysis to define terminating functions on the natural numbers
it is necessary to uniformly construct the input to both $f$ and $g$
due to the reduction rule of $[[fix]]$.  Thus, we extend the type of
$f$ to $[[Y x Nat]]$, but then ignore the second projection when
reaching the base case.

We now have all the necessary structure to describe the model of the
programmatic fragment.
\begin{definition}
  \label{def:P-model}
  A model of the programmatic fragment, called a
  \textbf{$\cat{P}$-model}, consists of a cartesian closed category,
  $\cat{C}$, with fixpoints and a SNNO.
\end{definition}
\noindent
The following definition gives an interpretation of types and typing
contexts into a $\cat{P}$-model.
\begin{definition}
  \label{def:term-interp}
  Suppose $\cat{P}$ is a $\cat{P}$-model.
  \begin{itemize}
  \item The interpretation of types as objects is as follows:
    \[
    \begin{array}{lll}
      \interp{[[True]]} & = & 1\\
      \interp{[[Nat]]} & = & [[Nat]]\\
      \interp{[[X x Y]]} & = & \interp{[[X]]} \times \interp{[[Y]]}\\
      \interp{[[X -> Y]]} & = & \interp{[[X]]} \to \interp{[[Y]]}\\      
    \end{array}
    \]

  \item The interpretation of typing contexts is as follows:
    \[
    \begin{array}{lll}
      \interp{\cdot} & = & 1\\
      \interp{[[G,x1 : X1]]} & = &
      \interp{[[G]]} \times \interp{[[X1]]}\\
    \end{array}
    \]
  \end{itemize}
  We always assume that the interpretation of typing contexts is
  right-associated.  
\end{definition}

The following result is mostly known, but we give the cases of the
proof that are most interesting.  The cases for SNNOs are novel, but
straightforward given their definition.
\begin{theorem}[Soundness]
  \label{theorem:P-soundness}
  Suppose $\cat{P}$ is a $\cat{P}$-model.
  \begin{itemize}
  \item[i.] If $[[G |-P t : X]]$, then there is a morphism,
    $\interp{[[t]]} : \interp{[[G]]} \mto \interp{[[X]]}$, in
    $\cat{P}$, and
  \item[ii.] If $[[G |-P t = t' : X]]$,
    then $\interp{[[t]]} = \interp{[[t']]}$ in $\cat{P}$.
  \end{itemize}
\end{theorem}
\begin{proof}
  We will prove part two explicitly which depends on part one in such
  away that proving part one and then part two would require a lot of
  repeated constructions.  We proceed by induction on the form of the
  assumed term-in-context derivation, but since the majority of the
  programmatic fragment is well-known to have a sound and complete
  interpretation into a cartesian closed category we only show the
  one of the cases for natural numbers.

  \begin{itemize}
    \begin{report}     
  First, recall that $\beta$-equality can be defined as follows in the
  model -- for any morphisms $f : B \times C \mto D$, $g : A \mto C$,
  and $h : A \to B$:
  \[
  \begin{array}{lllll}
    \langle h;\cur{f},g \rangle; \app_{B,C} & = &  \langle h,g \rangle;(\cur{f} \times \id_C);\app_{B,C}\\
    & = & \langle h, g\rangle;f\\
  \end{array}
  \]

  Using $\beta$-equality we can show what we call $[[fix]]$-equality --
  for any morphisms $f : A \to B$ and $g : B \to C$:
  \[
  \begin{array}{llll}
    \langle \cur{\pi_2;g},f \rangle;\app_{B,C}
    & = & \langle \id_A, f \rangle;\pi_2;g\\
    & = & f;g\\
  \end{array}
  \]
  
  
  \item[] Case.\ \\ 
    \begin{center}
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=\ifrName{Fix}] {
          [[G |-P t : X -> X]]
        }{[[G |-P fix t = t (fix t) : X]]}
      \end{math}
    \end{center}
    By part one we know there is a morphism:
    \[ \interp{[[G]]} \mto^{\interp{t}} \interp{[[X]]} \to \interp{[[X]]} \]
    of $\cat{P}$.  In addition, since any $\cat{P}$-model contains
    fixpoints we know there exists a morphism:
    \[
      (\interp{[[X]]} \to \interp{[[X]]}) \mto^{[[fix]]_{\interp{[[X]]}}} \interp{[[X]]}
    \]
    The interpretation of $[[G |-P fix : (X -> X) -> X]]$ is as follows:
    \[
    \interp{[[G]]} \mto^{\interp{[[G |-P fix : (X -> X) -> X]]} = \cur{\pi_2;[[fix]]_{\interp{[[X]]}}}} (\interp{[[X]]} \to \interp{[[X]]}) \to \interp{[[X]]}
    \]
    We obtain our result by the following equational reasoning:
    \[
    \scriptsize
    \begin{array}{lllll}
      \interp{[[G |-P fix t : X]]}\\
      \,\,\,\,\,\,= \langle \cur{\pi_2;[[fix]]_{\interp{[[X]]}}}, \interp{[[t]]} \rangle;\app_{\interp{[[X]]} \to \interp{[[X]]},\interp{[[X]]}}   & \text{(Definition)}\\
      \,\,\,\,\,\,= \interp{[[t]]};[[fix]]_{\interp{[[X]]}} & \text{($[[fix]]$-equality)}\\
      \,\,\,\,\,\,= \interp{[[t]]};\langle \id_{\interp{[[X]]} \to \interp{[[X]]}}, [[fix]]_{\interp{[[X]]}} \rangle;\app_{\interp{[[X]]},\interp{[[X]]}} & \text{(Fixpoint)}\\
      \,\,\,\,\,\,= \langle \interp{[[t]]}, \interp{[[t]]};[[fix]]_{\interp{[[X]]}} \rangle;\app_{\interp{[[X]]},\interp{[[X]]}} & \text{(Cartesian)}\\
      \,\,\,\,\,\,= \langle \interp{[[t]]}, \langle \cur{\pi_2;[[fix]]_{\interp{[[X]]}}},\interp{[[t]]} \rangle;\app_{\interp{[[X]]} \to \interp{[[X]]},\interp{[[X]]}} \rangle;\app_{\interp{[[X]]},\interp{[[X]]}} & \text{($[[fix]]$-equality)}\\
      \,\,\,\,\,\,= \langle \interp{[[t]]}, \langle \interp{[[G |-P fix : (X -> X) -> X]]},\interp{[[t]]} \rangle;\app_{\interp{[[X]]} \to \interp{[[X]]},\interp{[[X]]}} \rangle;\app_{\interp{[[X]]},\interp{[[X]]}} & \text{(Definition)}\\
      \,\,\,\,\,\,= \langle \interp{[[t]]}, \interp{[[G |-P fix t : X]]} \rangle;\app_{\interp{[[X]]},\interp{[[X]]}} & \text{(Definition)}\\
      \,\,\,\,\,\,= \interp{[[G |-P t (fix t) : X]]} & \text{(Definition)}\\      
    \end{array}
     \]

  \item[] Case.\ \\ 
    \begin{center}
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=\ifrName{CaseB}] {
          [[G |-P t1 : X && G, x : Nat |-P t2 : X]]
        }{[[G |-P case 0 {0 -> t1, suc x -> t2} = t1 : X]]}
      \end{math}
    \end{center}
    We have the following morphisms by part one:
    \[
    \begin{array}{c}
      \interp{[[G]]} \mto^{\interp{[[t1]]}} \interp{[[X]]}\\
      \\
      \interp{[[G]]} \times [[Nat]] \mto^{\interp{[[t2]]}} \interp{[[X]]}
    \end{array}
    \]
    Then by the definition of SNNO we know there exists an unique
    morphism
    \[ [[Y x Nat]] \mto^{\mathsf{case}_{\interp{[[X]]}}} \interp{[[X]]}\]
    such that the following is one equation that holds:
    \[
    \begin{array}{lll}
      (\id_{\interp{[[G]]}} \times \mathsf{z});\mathsf{case}_{\interp{[[X]]}} = \pi_1;\interp{[[t1]]}
    \end{array}
    \]
    
    We also have the following interpretation for any $\interp{[[G |-P t : Nat]]}$:
    \[
    \interp{[[case t {0 -> t1, suc x -> t2}]]} =
    \langle \id_{\interp{[[G]]}}, \interp{[[t]]} \rangle;\mathsf{case}_{\interp{[[X]]}} : \interp{[[G]]} \to \interp{[[X]]}
    \]
    Thus, we obtain our desired equality because $\interp{[[G |-P 0 : Nat]]} = \t_{\interp{[[G]]}};\mathsf{z}$:
    \[
    \begin{array}{lll}
      \langle \id_{\interp{[[G]]}}, \t_{\interp{[[G]]}};\mathsf{z} \rangle;\case_{\interp{[[X]]}}
      & = & \langle \id_{\interp{[[G]]}}, \t_{\interp{[[G]]}} \rangle;(\id_{\interp{[[G]]}} \times \mathsf{z});\case_{\interp{[[X]]}}\\
      & = & \langle \id_{\interp{[[G]]}}, \t_{\interp{[[G]]}} \rangle;\pi_1;\interp{[[t1]]}\\
      & = & \interp{[[t1]]}.\\
    \end{array}
    \]
\end{report}
  \item[] Case.\ \\ 
    \begin{center}
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=\ifrName{CaseS}] {
          [[G |-P n : Nat]]
          \\\\
          [[G |-P t1 : X && G, x : Nat |-P t2 : X]]
        }{[[G |-P case (suc n) {0 -> t1, suc x -> t2} = [n/x]t2 : X]]}
      \end{math}
    \end{center}
    We have the following morphisms by part one:
    \[
    \begin{array}{c}
      \interp{[[G]]} \mto^{\interp{[[n]]}} [[Nat]]\\
      \\
      \interp{[[G]]} \mto^{\interp{[[t1]]}} \interp{[[X]]}\\
      \\
      \interp{[[G]]} \times [[Nat]] \mto^{\interp{[[t2]]}} \interp{[[X]]}
    \end{array}
    \]
    Then by the definition of SNNO we know there exists an unique
    morphism
    \[ [[Y x Nat]] \mto^{\mathsf{case}_{\interp{[[X]]}}} \interp{[[X]]}\]
    such that the following is one equation that holds:
    \[
    \begin{array}{lll}
      (\id_{\interp{[[G]]}} \times \mathsf{suc});\mathsf{case}_{\interp{[[X]]}} = \interp{[[t2]]}
    \end{array}
    \]
    
    We also have the following interpretation for any $\interp{[[G |-P t : Nat]]}$:
    \[
    \interp{[[case t {0 -> t1, suc x -> t2}]]} =
    \langle \id_{\interp{[[G]]}}, \interp{[[t]]} \rangle;\mathsf{case}_{\interp{[[X]]}} : \interp{[[G]]} \to \interp{[[X]]}
    \]
    We obtain our result because $\interp{[[G |-P suc n : Nat]]} = \interp{[[n]]};\mathsf{suc}$:
    \[
    \begin{array}{lll}
      \langle \id_{\interp{[[G]]}}, \interp{[[n]]};\mathsf{suc} \rangle;\mathsf{case}_{\interp{[[X]]}}
      &  = & \langle \id_{\interp{[[G]]}}, \interp{[[n]]} \rangle;(\id_{\interp{[[G]]}} \times \mathsf{suc});\mathsf{case}_{\interp{[[X]]}}\\
      &  = & \langle \id_{\interp{[[G]]}}, \interp{[[n]]} \rangle;\interp{[[t2]]}.
    \end{array}
    \]
  \end{itemize}
\end{proof}
% subsection the_programmatic_fragment (end)
% section the_fragments_and_their_semantics (end)

\section{A Termination/Non-Termination Adjoint Model}
\label{sec:a_termination/non-termination_adjoint_model}
We have so far laid out both the syntactic and categorical
formalizations of the logical fragment and the programmatic fragment.
At this point we turn to joining these two fragments together using an
adjunction, but before this we must acquaint ourselves with the basic
notions involved in the construction of such a model.

\subsection{The Basic Tools}
\label{subsec:the_basic_tools}
We have been working in cartesian closed categories, but much of the
basic categorical tools we will employ arose from the study of
symmetric monoidal closed categories which are at the heart of
categorical models of linear logic.
% subsection the_basic_tools (end)
% section a_termination/non-termination_adjoint_model (end)


\section{Related Work}
\label{sec:related_work}
\todo[inline]{Write}
% section related_work (end)

\section{Conclusion}
\label{sec:conclusion}
\todo[inline]{Write}
% section conclusion (end)

\bibliographystyle{plain}
\bibliography{ref}

\nocite{*}
\appendix

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
